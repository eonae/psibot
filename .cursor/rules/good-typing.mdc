---
globs:
  - **/*.ts
  - **/*.tsx
alwaysApply: true
---

- Общие принципы
  - Никогда не использовать any и non-null assertion (!). Не делать unknown → any.
  - Не использовать беспричинные приведения типов (`as T`). Приводить только после валидации/парсинга.
  - У всех экспортируемых функций/классов — явные типы параметров и возвращаемых значений.
  - Не опускать типы Promise и дженерики; не полагаться на неявный `any`.

- Внешние данные и адаптеры
  - Любые данные извне (Mongo/HTTP/файлы) сначала валидировать/приводить по схеме:
    - TypeBox: `Value.Check/Value.Cast` + схемы из проекта (или локальные).
  - Для Mongo: типизированные коллекции `db.collection<T>()` и обязательный `Value.Cast` на вход/выход.
  - Для Drizzle jsonb: использовать `$type<T>()` в схеме таблицы.

- Работа с типами
  - Предпочитать:
    - `satisfies`, `as const`, точные литеральные типы.
    - Юнионы + исчерпывающие `switch` c веткой `never`.
    - Пользовательские type-guards вместо «жёстких» `as`.
  - Не использовать `{} | object` там, где можно описать форму данных.
  - Избегать `as unknown as T`; вместо этого — промежуточный валидируемый тип.
  - Избегать inline типов (определения типов в сигнатуре функции) - по возможности давать типам осмысленные названия

- Исключения
  - Если строго без `any` невозможно (вендор/узкое место) — выделить в отдельный адаптер с минимальной поверхностью и кратким комментарием почему. Перед применением — запросить подтверждение у автора.

- Приоритет источников типов
  - Сначала — существующие типы/схемы проекта, затем типы библиотек, затем собственные.